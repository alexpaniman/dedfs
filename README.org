*DEDFS* (~DEDuplicating File System~)--- это маленькая ~in-memory~ файловая
система на основе ~FUSE~, которая использует ~in-line~ дедупликацию данных.

Дедупликация данных (наряду с сжатием файлов) --- очень актуальная
задачах для систем с ограниченной памятью, в особенности для файловых
систем распологающихся в оперативной памяти, которой, как правило, немного.

* Требования
+ ~In-memory~ (Файловая система должна хранить файлы в оперативной памяти
  для быстрого чтения и записи. Такого рода файловые системы полезны для
  временных, но активно используемых файлов. К примеру, в оперативную
  память нередко монтируют ~tmpfs~)

+ Скорость (Файловая система должна быть быстрой, иначе нет никакого
  смысла располагать файлы в оперативной памяти)

+ ~In-line~ дедупликация (Дедупликация файлов должна происходить сразу
  (во время записи нового файла), чтобы минимизировать использование памяти
  в каждый конкретный момент времени и избавиться от слабо предсказуемой
  накладной нагрузки на процессор во время простоя файловой системы)

* Реализация

** Платформа

В качестве платформы для реализации ~VFS~ был выбран ~FUSE~ (~Filesystem in
USErspace~) --- система, которая предоставляет удобный ~API~ для
написания файловых систем, которые потом, благодаря её драйверу, можно
запускать, как можно догадаться из названия, в ~user-space~.

Платформа позволяет достаточно легко и безопасно (без написания
драйвера в ~0м~ кольце привелегий) получить работающую файловую систему,
которая для локального использования не будет иметь особенных недостатков.

** Хранение файлов

Центральной идеей *DEDFS* является разбиение файлов на некоторые кусочки
(далее --- _блоки_) одинакового размера (например, 4096 байт, как будет
показано во многих последующих примерах):

cludegraphics[width=\textwidth]{img/separate-in-blocks.

При этом, очевидно, что разбить на кусочки размера 4096 байт можно далеко
не любой файл. Поэтому, внутри блока отдельно хранится его реальный
размер. И, если какой-то файл занял нецелое число блоков, то последний
блок окажется меньше своего "природного" размера, что будет отражено в
соответствующем его поле.

Такая архитектура дает нам серьезное преимущество, которое лежит в
основе системы дедупликации данных *DEDFS*: один блок может повторятся в
нескольких файлах, да и не только в нескольких, но и, даже, внутри
одного. И если вместо самих блоков в файле хранить список указателей
на них, то такого рода общие части будет очень легко выразить, как
видно на иллюстрации на следующей странице. 

[[file:img/share-blocks.png]]

** Аллокация
Сами файлы тоже нужно где-то хранить. Хорошим вариантом был бы,
например, динамический массив:

[[file:img/store-files-in-a-list.png]]

Но, при удалении файлов (что происходит нередко), внутри массива
появятся пустоты, которые сильно затруднят взаимодействия со структурой

[[file:img/delete-files.png]]

Решить эту проблему достаточно несложно: достаточно собрать связный
список из файлов, фактически образуя кастомный аллокатор, который
сможет как выделять место под новые файлы за амортизированное
время ~O(1)~, в отличие от обычных аллокаций (с помощью семейства
функций ~alloc~), которые, как правило, работают за ~O(n)~, где ~n~ --- 
количество уже совершенных аллокаций, так и эффективно использовать 
место освобожденное после удаления файлов из середины массива:

[[file:img/free-space-can-be-reused.png]]

** Дедупликация

Мы придумали как хранить файлы и их элементарные кусочки. Но
для дедупликации нам пока ещё нехватает способа эффективно искать
повторяющиеся блоки памяти. Ведь сейчас для этого нужно обойти
весь список, и сравнить каждые два блока памяти, это *очень* дорого.

Нам нужен некторый ассоциативный контейнер, в котором можно будет
быстро находить одинаковые блоки. На наше счастье, такая структура
данных уже давно известна --- это хэш таблица. Вычисляя хэши
блоков и распределяя их соответственно в нужные ячейки потенциально
можно добиться поиска за амортизированное время ~O(n)~ (считая время
подсчета хэша константным так как максимальный размер блока у нас
константный).

[[file:img/use-hashmap-to-find-same-blocks.png]]

** Поиск файлов в файловой системе

В принципе, у нас уже есть минимальная, но тем не менее, достаточно
функциональная файловая система с поддержкой дедупликации.

Главная проблема в том что поиск файлов пока что крайне долгий. Нужно,
опять же, проходить по всему массиву, пока не будет встречен нужный
файл, то есть у нашего поиска ассимптотика ~O(n)~, где ~n~ --- количествой
файлов в файловой системе. Решение тут, как и в прошлый раз, --- хэш-таблица.

[[file:img/whole-file-storage.png]]
